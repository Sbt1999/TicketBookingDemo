âœ… Why we are not using synchronized here

ğŸ”¹ 1. AtomicInteger gives built-in thread-safety without locks
AtomicInteger uses lock-free, atomic operations internally using CPU-level
Compare-And-Swap (CAS) instructions. So:

java
Copy
Edit
booked.incrementAndGet();  // âœ” thread-safe, lock-free
This is faster and more scalable than doing:

java
Copy
Edit
synchronized (this) {
    booked++;
}
ğŸ”¹ 2. We donâ€™t need to synchronize just to increment
If you only need to safely increment a counter, AtomicInteger is perfect.

Using synchronized:

Has more overhead (acquire/release lock)
-----------------------------------------------------
Can become a bottleneck under high thread contention
------------------------------------------------------
Is overkill for a simple ++ operation

ğŸ”¹ 3. We're already using a separate concurrency mechanism (Semaphore)
In your current design:

The Semaphore controls booking access (whether a seat is available)

AtomicInteger is just tracking how many bookings happened

So we don't need extra synchronization â€” the Semaphore ensures only one thread
can decrement the available seat count.

ğŸ” Where you would use synchronized instead:
Youâ€™re protecting multiple fields together (e.g., available and booked)

You need to implement a critical section (e.g., reading â†’ modifying â†’ writing multiple shared variables)

Youâ€™re not using atomic or concurrent data structures (AtomicInteger, ConcurrentHashMap, etc.)

âœ… TL;DR
We're not using synchronized because AtomicInteger is already thread-safe, lock-free,
and more performant for simple counters.
The actual seat availability is controlled by the Semaphore, and booked.incrementAndGet()
is safe and efficient as-is.

Let me know if you'd like a version that compares synchronized vs AtomicInteger in a mini benchmark!